shading mode : 渲染方式  shaded :着色器渲染  wraframe :网格渲染
alt + 鼠标左键 ： 绕着某个物体旋转   F  ：选中某个物体 Ctrl+7直接打开调试窗口
ProjectSetting文件夹:存储unity的所有设置
Unity中反射的体现：首先反射是程序运行时查看自身或其他程序集的行为。unity中Gameobject所依附的一个个组件实际上就是类，通过这些类的逻辑去驱动Gameobject的各种行为，
我们修改检查面板中的属性值，实际上就是修改了这些类的元数据，进而去影响了Gameobject的行为。而场景本身就是一个配置文件，他里面记录了所有的这些元数据，我们之所以能够
获得并修改这些元数据，实际上是通过这个配置文件实现的。
monobehaviour 不能new.因为继承了mono的类unity会在运行时默认执行一个无参的构造函数。所有写构造函数没有意义，因为Awake start就能实现构造函数的功能，而且unity的变成规范不允许你写。
[DisAllowMultipleComponent]
生命周期如何实现：继承来的mono的类，unity会把他们记录下来，在主线程的死循环中，unity引擎按顺序按时机通过函数名进行反射，得到并执行对应的脚本对象的对应的生命周期。
[ContextMenu("Test")]   [Range(0,10)]  [ContextMenuItem("ResetName","Test")]
Time.timeScale 取值0-100之间，超出会报错。会影响fixedupdate的执行速度，但是不会影响uodate,latedupdate的执行速度。只是会改变time.deltaTime的值。
scale = 2 实际上就是吧时间拉长了2倍。
transform.SetParent(parent,false)//TRUE 表示会保留世界坐标系下的状态
世界坐标转本地坐标 transform.InverseTransformPoint(Vector3.forward) //可以大概判断在自己的什么方位
本地坐标转世界坐标 transform.TransformPoint (Vector3.forward)  //常用，可以在自己面前或者哪里创建一团火
动态模糊：相机的拍照不是瞬时的，而是与曝光时间有关，对于运动的物体来说，传入相机传感器的信息会持续改变并叠加产生模糊的效果，而曝光时间过段，就会导致近光量不足
进而无法获得足够的环境信息，而人之所以不觉模糊是因为大脑的视觉修正通过联想前后的画面，从而产生了连续的画面。赛车游戏会通过动态模糊提升游戏的真实感。
而unity每一帧的画面都是实时计算出来的。如果前后两帧画面差异较大，就会给人卡顿的感觉。因此需要一定程度上设置动态模糊
显示器在刷新画面时，会逐行扫描屏幕像素，这些水平扫描线在垂直方向上的堆积就形成了完整的画面，因此一个画面是逐行或者逐列进行渲染的。开启垂直同步的话，就会等待
垂直同步信号到达后才会绘制下一帧，这样就不会导致出现画面撕裂的现象
  Camera.onPreCull += (c) =>
        {
            //摄像机进行剔除前处理的委托函数
        };
        Camera.onPreRender += (c) =>
        {
            //摄像机渲染前处理的委托
        };
        Camera.onPostRender += (c) =>
        {
            //摄像机渲染后处理的委托
        };
         //世界坐标转屏幕坐标  Z对应的是这个物体离我们的摄像机有多远
        Vector3 v = Camera.main.WorldToScreenPoint(this.transform.position);
         //屏幕坐标转世界坐标(v表示的是这个横切面离我们摄像机的距离)
        //含义就是把屏幕坐标的运动转换为这个横切面上的运动
        v = Input.mousePosition;
        v.z = 10;
        print(Camera.main.ScreenToWorldPoint(v));
        light ： Area light 主要是烘焙用的   Cookie (投影遮罩)：选择图片进而去产生一个叠加显示的阴影  Draw halo (球形光环开关):做一个蜡烛的效果，光晕效果
        // Flare (耀斑):，耀斑就是耀斑，特殊格式的美术资源，想要看到需要给摄像机添加flare layer组件
        Indirect Multipiler：改变间接光的强度，低于1，每次反弹会使光更暗，高于1 ，每次单谈会使光更亮
        //携程的本质是unity的协程调度器根据yield return 的返回值去执行协程的函数体
        //Resources文件夹下的资源不会直接加载进内存，只是说引擎启动时会创建一个Resources索引表，Resources文件夹下文件越多，索引表也就越大，这个是会占用内存的。
         //位运算好处是一个int可以检测所有想要检测的层级信息。先把我们的位运算的得到的多个值进行或运算得到一个二进制数。这个二进制数和其他所有层进行与运算，结果为0就表示排除该检测层。
        Physics.OverlapSphere(Vector3.zero, 5, 1 << LayerMask.NameToLayer("UI"));
